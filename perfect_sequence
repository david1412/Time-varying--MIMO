# Task 4.1.1
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import pylab as pl
from scipy import signal as sg
from scipy import fftpack as spfft
import soundfile as sf

def calculate_perfect_sweet(M, factor):
    p = []
    id = 0
    MM = np.max(M)
    for M_i in M:
        if (M_i < 0):
            print("Please enter nyu value bigger than 0!")
            return 0;
        if(M_i < MM/2):
            m = MM / factor
            xx = np.exp(-1j*4*m*np.pi*np.square(M_i)/np.square(MM))
            p.append(xx)
            id = id + 1
        if(M_i >= MM/2):
            xx = np.conjugate(p[int(id-MM/2)])*(MM-M_i)
            p.append(xx)
            id = id + 1
    return p

def display_perfect_sweet(M, factor):
    p = calculate_perfect_sweet(M, factor)
    out = np.abs(p)
    top = np.max(out)
    base = 0

    print('Plotting perfect_sweet...')
    fig = pl.figure()
    pl.plot(M, out)
    pl.ylim(base, top)
    #pl.xticks(np.arange(np.min(out), np.max(out), 100))
    pl.grid(True)
    pl.xlabel('M')
    pl.ylabel('Amplitude')

    pl.title("Perfect sweep")
    pl.show()
    return 0

def display_DFT(M, factor):
    p = calculate_perfect_sweet(M, factor)
    fft_sig = spfft.fft(p, n=len(M))

    out = np.real(fft_sig)
    top = np.max(out)
    base = 0

    print('Plotting DFT...')
    fig = pl.figure()
    pl.plot(M, out)
    pl.ylim(base, top)
    #pl.xticks(np.arange(np.min(out), np.max(out), 100))
    pl.grid(True)
    pl.xlabel('M')
    pl.ylabel('Amplitude')

    pl.title("DFT")
    pl.show()
    return 0


def display_IDFT(M, factor):
    p = calculate_perfect_sweet(M, factor)
    fft_sig = spfft.ifft(p, n=len(M))

    out = np.real(fft_sig)
    top = np.max(out)
    base = 0

    print('Plotting DFT...')
    fig = pl.figure()
    pl.plot(M, out)
    pl.ylim(base, top)
    #pl.xticks(np.arange(np.min(out), np.max(out), 100))
    pl.grid(True)
    pl.xlabel('M')
    pl.ylabel('Amplitude')

    pl.title("IDFT")
    pl.show()
    return 0


def display_phase(M, factor):
    p = calculate_perfect_sweet(M, factor)
    fft_sig = spfft.fft(p, n=len(M))
    time_sign = []
    for xxx in fft_sig:
        time_sign.append(np.imag(xxx)/np.real(xxx))

    top = np.max(time_sign)
    base = 0

    print('Plotting Time domain...')
    fig = pl.figure()
    pl.plot(M, time_sign)
    pl.ylim(base, top)
    #pl.xticks(np.arange(np.min(out), np.max(out), 100))
    pl.grid(True)
    pl.xlabel('M')
    pl.ylabel('Phase')

    pl.title("Phase")
    pl.show()
    return 0


def display_spectrogram(M, factor):
    p = calculate_perfect_sweet(M, factor)
    fs = 1
    f, t, Sxx = sg.spectrogram(p, fs)
    pl.pcolormesh(t, f, Sxx)
    pl.ylabel('Frequency [Hz]')
    pl.xlabel('Time [sec]')
    pl.show()
    return 0

def auto_correlation(M, factor):# it doesn't work'
    p = calculate_perfect_sweet(M, factor)
    fft_sig = spfft.fft(p, n = len(M))
    time_sign = []
    for xxx in fft_sig:
        time_sign.append(np.imag(xxx)/np.real(xxx))

    top = np.max(time_sign)
    base = 0

    print('Plotting Time domain...')
    fig = pl.figure()
    pl.plot(M, time_sign)
    pl.ylim(base, top)
    #pl.xticks(np.arange(np.min(out), np.max(out), 100))
    pl.grid(True)
    pl.xlabel('M')
    pl.ylabel('Phase')

    pl.title("Phase")
    pl.show()
    return 0

M_array = np.arange(1,308)
M = np.array(M_array, np.dtype(int))
m_val = M/2
factor = 2
display_perfect_sweet(M, factor)
display_DFT(M, factor)
display_IDFT(M, factor)
display_phase(M, factor)
#display_spectrogram(M, factor)
