import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import pylab as pl
import scipy
#from scipy import signal as sg
#from scipy import fftpack as spfft
import soundfile as sf

def display_perfect_sweet(nyu, M, P_pulse, factor):
    if (nyu<0):
        print("Please enter nyu value bigger than 0!")
        return 0;
    x = []
    for M_i in M:
        if(nyu < M_i/2):
            m = M_i / factor
            xx = np.exp(-1j*4*m*np.pi*np.square(1/M_i)/np.square(M_i))
            x.append(xx)
        if(nyu >= M_i/2):
            xx = M_i*(M_i-1/M_i)
            x.append(xx)


    out = np.abs(x)
    top = np.max(out)
    base = 0

    print('Plotting perfect_sweet...')
    fig = pl.figure()
    pl.plot(M, out)
    pl.ylim(base, top)
    #pl.xticks(np.arange(np.min(out), np.max(out), 100))
    pl.grid(True)
    pl.xlabel('M')
    pl.ylabel('Amplitude')

    pl.title("Perfect sweep")
    pl.show()
    return 0

def display_DFT(nyu, M, P_pulse, factor):
    if (nyu<0):
        print("Please enter nyu value bigger than 0!")
        return 0;
    x = []
    for M_i in M:
        if(nyu < M_i/2):
            m = M_i / factor
            xx = np.exp(-1j*4*m*np.pi*np.square(1/M_i)/np.square(M_i))
            x.append(xx)
        if(nyu >= M_i/2):
            xx = M_i*(M_i-1/M_i)
            x.append(xx)

    fft_sig = scipy.fft(x, n=len(x))

    out = np.abs(fft_sig)
    top = np.max(out)
    base = 0

    print('Plotting DFT...')
    fig = pl.figure()
    pl.plot(M, out)
    pl.ylim(base, top)
    #pl.xticks(np.arange(np.min(out), np.max(out), 100))
    pl.grid(True)
    pl.xlabel('M')
    pl.ylabel('Amplitude')

    pl.title("DFT")
    pl.show()
    return 0

def display_time_domain(nyu, M, P_pulse, factor):
    if (nyu<0):
        print("Please enter nyu value bigger than 0!")
        return 0;
    x = []
    for M_i in M:
        if(nyu < M_i/2):
            m = M_i / factor
            xx = np.exp(-1j*4*m*np.pi*np.square(1/M_i)/np.square(M_i))
            x.append(xx)
        if(nyu >= M_i/2):
            xx = M_i*(M_i-1/M_i)
            x.append(xx)

    fft_sig = scipy.fft(x, n=len(x))

    time_sign = []
    for xxx in fft_sig:
        time_sign.append(np.imag(xxx)/np.real(xxx))

    top = np.max(time_sign)
    base = 0

    print('Plotting Time domain...')
    fig = pl.figure()
    pl.plot(M, time_sign)
    pl.ylim(base, top)
    #pl.xticks(np.arange(np.min(out), np.max(out), 100))
    pl.grid(True)
    pl.xlabel('M')
    pl.ylabel('Phase')

    pl.title("Phase")
    pl.show()
    return 0


M_array = np.arange(1,308)
M = np.array(M_array, np.dtype(int))
m_val = M/2
nyu = 100
P_pulse = 1/nyu
factor = 2
display_perfect_sweet(nyu, M, P_pulse, factor)

display_DFT(nyu, M, P_pulse, factor)

display_time_domain(nyu, M, P_pulse, factor)
